#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "constants.h"
#include "parser.h"
#include "colors.h"
#include "user/program.h"
#include "user/config.h"
#include "debugger/dumper.h"
#include "str.h"
#include "messages.h"
#include "errors.h"
#include "config_flags.h"

int parse(FILE *inputFile)
{
    CurrentLine.number = 1;
    Program.pointer = 0;
    Program.loopDepth = 0;
    for (int i = 0; i < DIPLO_ARRAY_SIZE; i++)
    {
        Program.array[i] = 0;
    }
    

    int fileLineNumber = 0;
    char tempLineRaw[MAX_LINE_SIZE];
    while (fgets(tempLineRaw, MAX_LINE_SIZE, inputFile) != NULL)
    {
        strcpy(Program.lines[fileLineNumber], tempLineRaw);
        Program.linesNumber++;
        fileLineNumber++;
    }

    for (int i = 1; i <= Program.linesNumber; i++)
    {
        if(parse_line(i)) return 1;
    }
    
    // if(parse_line(1)) return 1;
    
    if (Program.loopDepth)
    {
        printf("%#x%s Invalid loop depth at the end of program.", ERR_LOOP_DEPTH, MSG_FATAL_ERROR, CurrentLine.trimmed, CurrentLine.number);
        return 1;
    }
    if (config_flag_exists('d'))
        printf("\n\n\nDebug: [%d, %d, %d, %d, %d, %d, %d, %d, %d, %d]", Program.array[0], Program.array[1], Program.array[2], Program.array[3], Program.array[4], Program.array[5], Program.array[6], Program.array[7], Program.array[8], Program.array[9]);

    // green_bold();
    // printf("\nDumping...\n");
    // color_reset();
    // FILE *outputFile = fopen("dump.json", "w");
    // dump_array(Program.array, outputFile);
    // fclose(outputFile);

    return 0;
}

int parse_line(const int lineNumber)
{
    strcpy(CurrentLine.raw, Program.lines[lineNumber-1]);
    CurrentLine.number = lineNumber;
    // printf("Received parse: %d (%s)\n", lineNumber, CurrentLine.raw);

    // printf("%s\n", CurrentLine.raw);
    CurrentLine.trimmed = str_trim(CurrentLine.raw); 

    // If line is not empty
    if(strlen(CurrentLine.trimmed) != 0)
    {
        CurrentLine.exploded.space.content = str_explode(CurrentLine.trimmed, " ", 0, &CurrentLine.exploded.space.length);
        
        // printf("Line %d length: %d\n", CurrentLine.number, CurrentLine.exploded.space.length);

        char statementToLower[MAX_LINE_SIZE];
        strcpy(statementToLower, CurrentLine.exploded.space.content[0]);
        str_tolower(statementToLower);
        
        // Comments
        if (strcmp(statementToLower, "//") == 0) {}
        else if (strcmp(statementToLower, "insert") == 0)
        {
            if (CurrentLine.exploded.space.length < 2)
            {
                char error[MAX_ERR_SIZE];
                sprintf(error, "Expected argument after '%s' on line %d.", CurrentLine.exploded.space.content[0], CurrentLine.number);
                return derr(ERR_EXPECTED_ARGUMENT, error, CurrentLine.number);
            }

            // Insert +
            if (CurrentLine.exploded.space.content[1][0] == '+')
            {
                if(strlen(CurrentLine.exploded.space.content[1]) < 2)
                {
                    Program.array[Program.pointer]++;
                }
                // +n
                else
                {
                    char *toAddStr = CurrentLine.exploded.space.content[1] + 1;
                    int toAdd = atoi(toAddStr);
                    Program.array[Program.pointer] += toAdd;
                }
            }
            // Insert -
            else if (CurrentLine.exploded.space.content[1][0] == '-')
            {
                if(strlen(CurrentLine.exploded.space.content[1]) < 2)
                {
                    Program.array[Program.pointer]--;
                }
                // -n
                else
                {
                    char *toAddStr = CurrentLine.exploded.space.content[1] + 1;
                    int toAdd = atoi(toAddStr);
                    Program.array[Program.pointer] -= toAdd;
                }
            }
            // If argument starts with a num
            else if (CurrentLine.exploded.space.content[1][0] >= 48 && CurrentLine.exploded.space.content[1][0] <= 57)
            {
                int newValue = atoi(CurrentLine.exploded.space.content[1]);
                Program.array[Program.pointer] = newValue;
            }
            else
            {
                char error[MAX_ERR_SIZE];
                sprintf(error, "Invalid argument '%s' on line %d.", CurrentLine.exploded.space.content[1], CurrentLine.number);
                return derr(ERR_INVALID_ARGUMENT, error, CurrentLine.number);
            }
        }
        else if (strcmp(statementToLower, "ptr") == 0 || strcmp(statementToLower, "pointer") == 0)
        {
            if (CurrentLine.exploded.space.length < 2)
            {
                char error[MAX_ERR_SIZE];
                sprintf(error, "Expected argument after '%s' on line %d.", CurrentLine.exploded.space.content[0], CurrentLine.number);
                return derr(ERR_EXPECTED_ARGUMENT, error, CurrentLine.number);
            }

            // Ptr +
            if (CurrentLine.exploded.space.content[1][0] == '+')
            {
                if(strlen(CurrentLine.exploded.space.content[1]) < 2)
                {
                    Program.pointer++;
                }
                // +n
                else
                {
                    char *toAddStr = CurrentLine.exploded.space.content[1] + 1;
                    int toAdd = atoi(toAddStr);
                    Program.pointer += toAdd;
                }
            }
            // Ptr -
            else if (CurrentLine.exploded.space.content[1][0] == '-')
            {
                if(strlen(CurrentLine.exploded.space.content[1]) < 2)
                {
                    Program.pointer--;
                }
                // -n
                else
                {
                    char *toAddStr = CurrentLine.exploded.space.content[1] + 1;
                    int toAdd = atoi(toAddStr);
                    Program.pointer -= toAdd;
                }
            }
            // If argument starts with a num
            else if (CurrentLine.exploded.space.content[1][0] >= 48 && CurrentLine.exploded.space.content[1][0] <= 57)
            {
                int newValue = atoi(CurrentLine.exploded.space.content[1]);
                Program.pointer = newValue;
            }
            else
            {
                char error[MAX_ERR_SIZE];
                sprintf(error, "Invalid argument '%s' on line %d.", CurrentLine.exploded.space.content[1], CurrentLine.number);
                return derr(ERR_INVALID_ARGUMENT, error, CurrentLine.number);
            }
        }
        else if (strcmp(statementToLower, "out") == 0)
        {
            putchar(Program.array[Program.pointer]);
        }
        else if (strcmp(statementToLower, "get") == 0)
        {
            // scanf("%c", Program.array[Program.pointer]);
            Program.array[Program.pointer] = getchar();
        }
        // Loops
        else if (strcmp(statementToLower, "begin") == 0)
        {
            Program.loopDepth++;

            if (CurrentLine.exploded.space.length < 2)
            {
                char error[MAX_ERR_SIZE];
                sprintf(error, "Expected argument after '%s' on line %d.", CurrentLine.exploded.space.content[0], CurrentLine.number);
                return derr(ERR_EXPECTED_ARGUMENT, error, CurrentLine.number);
            }

            if (strcmp(CurrentLine.exploded.space.content[1], "repeat"))
            {
                printf("%d-%d\n", CurrentLine.number, search_line("End Repeat", Program.loopDepth-1, 1));

                if (CurrentLine.exploded.space.length < 3)
                {
                    char error[MAX_ERR_SIZE];
                    sprintf(error, "Expected argument after '%s' on line %d.", CurrentLine.trimmed, CurrentLine.number);
                    return derr(ERR_EXPECTED_ARGUMENT, error, CurrentLine.number);
                }

                int loopStartLine = CurrentLine.number;
                int loopEndLine = search_line("End Repeat", Program.loopDepth-1, 1);
                
                int repeatNumber = atoi(CurrentLine.exploded.space.content[2]);
                for (int i = 0; i < repeatNumber; i++)
                {
                    for (int j = 1; j < loopEndLine; j++)
                    {
                        if (j > loopStartLine) parse_line(j);
                    }
                    
                }
                
            }
        }
        else if (strcmp(statementToLower, "end") == 0)
        {
            Program.loopDepth--;
            if (Program.loopDepth < 0)
            {
                char error[MAX_ERR_SIZE];
                sprintf(error, "Invalid loop ending at '%s' on line %d.", CurrentLine.trimmed, CurrentLine.number);
                return derr(ERR_LOOP_DEPTH, error, CurrentLine.number);
            }
        }
        else
        {
            char error[MAX_ERR_SIZE];
            sprintf(error, "Unknown statement '%s' on line %d.", CurrentLine.exploded.space.content[0], CurrentLine.number);
            return derr(ERR_UNKNOWN_STATEMENT, error, CurrentLine.number);
        }
    }

    return 0;
}

int search_line(char *search, int occurence, int reverse)
{
    int found = 0;
    int matchLines[MAX_LINE_NUMBER];
    int matchI = 0;

    char searchFormatted[MAX_LINE_SIZE];
    strcpy(searchFormatted, search);
    str_tolower(searchFormatted);

    for (int i = 0; i <= Program.linesNumber; i++)
    {
        // To lower and trim
        char line[MAX_LINE_SIZE];
        if (reverse)
        {
            strcpy(line, Program.lines[Program.linesNumber-i]);
        }
        else
        {
            strcpy(line, Program.lines[i]);
        }
        str_tolower(line);
        char *lineTrimmed = str_trim(line);
        strcpy(line, lineTrimmed);
        if (strcmp(searchFormatted, line) == 0)
        {
            found = 1;
            matchLines[matchI] = i;
            matchI++;
        }
    }
    
    if (reverse) return found
        ? (matchLines[occurence]
            ? Program.linesNumber-(matchLines[occurence]) + 1
            : 0)
        : 0;
    return found
        ? (matchLines[occurence]
            ? matchLines[occurence] + 1
            : 0)
        : 0;
}